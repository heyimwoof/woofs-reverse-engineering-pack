<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PsiGen</name>
    </assembly>
    <members>
        <member name="M:JetBrains.ReSharper.PsiGen.Generator.IGeneratorHelper.GenerateLookaheadCheck(System.Collections.Generic.HashSet{JetBrains.ReSharper.PsiGen.Rules.TerminalOccurrence},JetBrains.ReSharper.PsiGen.Generator.CodeWriter)">
            Generates an expression which checks whether a lookahead in a given set
            of terminals
            
            @param first   set of terminals
            @param printer
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Generator.IGeneratorHelper.GenerateMatch(JetBrains.ReSharper.PsiGen.Terminal,System.String,JetBrains.ReSharper.PsiGen.Generator.CodeWriter)">
            Generates statement that advances lexer
            
            @param specialChecking
            @param outputStream
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Multilevel.ComplexParsingLevel.MyParserBodyGenerator.GenerateParserBody(JetBrains.ReSharper.PsiGen.Generator.IGeneratorHelper,JetBrains.ReSharper.PsiGen.Generator.CodeWriter)">
             Generates parser <i>body</i> for this level
            
             @param helper
             @param printer
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Nonterminal.CapitalizeName(System.String)">
             inserts underscores between words and converts <code>name</code> to uppercase.
            
             @param name
        </member>
        <member name="T:JetBrains.ReSharper.PsiGen.Rules.AbstractRule">
            <summary>
            Rule for abstract nonterminals which do not have a defining rule.
            Current implementation is such that FIRST and FOLLOW of an abstract
            rule always contain an epsilon string. This means, e.g., that error
            handling will <i>skip</i> abstract nonterminals
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.PsiGen.Rules.MultiRule">
            <summary>
            Base class for rules with multiple occurring subrules
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Rules.OrRule.GenerateGetChildRole(JetBrains.ReSharper.PsiGen.Generator.CodeWriter)">
             Generates getChildRole for OrRule.
            
             @param printer
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Rules.Rule.Labels(System.Collections.Generic.List{JetBrains.ReSharper.PsiGen.Label})">
            Adds all labels that are defined in the rule to the list
            
            @param list 
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Rules.Rule.FirstHasEpsilon">
            Determines whether this rule's FIRST contains an epsilon string
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Rules.Rule.GetPhantoms">
            Returns an ordered list of "phantoms" that are hanged on this rule's creation
            
            @return null if no phantoms can be reasonably hanged by this rule parsing
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Rules.Rule.First(System.Collections.Generic.HashSet{JetBrains.ReSharper.PsiGen.Rules.TerminalOccurrence})">
            Calculates a FIRST set (without an epsilon string)
            
            @param result a set of TerminalOccurrence
            @see TerminalOccurrence
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Rules.Rule.PsiFirst(System.Collections.Generic.HashSet{JetBrains.ReSharper.PsiGen.Symbol})">
            Adds set of Symbols (terminals or nonterminals) that may start parsing result
            of the rule.
            
            @param result 
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Rules.Rule.UpdateTails(System.Collections.Generic.HashSet{JetBrains.ReSharper.PsiGen.NonterminalTail})">
            <summary>
            Adds nonterminal tails that are generated by this rule.
            </summary>
            <param name="nonterminalTails">HashSet of NonterminalTails</param>
        </member>
        <member name="T:JetBrains.ReSharper.PsiGen.Tasks.ParserGenTaskStub">
            <summary>
            Invokes the Parser Generator.
            
            Expected parameters (task items with metadata <c>ParameterName</c> equal to these):
            • <c>Inputs</c>, multiple input files to process. Metadata:
            • • <c>FullPath</c> — full path to the input file.
            • <c>OutputFolder</c> — the single folder to write all outputs into. Metadata:
            • • <c>FullPath</c> — full path to the folder.
            • <c>DontCache</c> — do not use distributed cache, if present.
            • <c>DistributedCacheSettings</c> — allows to turn on network upload.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Tasks.ParserGenTaskStub.#ctor(System.Collections.Generic.Dictionary{System.String,System.String}[],System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.String}},System.Collections.Generic.IDictionary{System.String,System.Action{System.String}})">
            <summary>
            This complies with the <c>ProxyToSolutionCompiledTask</c> calling convention.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.PsiGen.Tasks.RemoveItemsInFolderTaskStub">
            <summary>
            Scans through the item group and removes any items that fall under the given folder.
            Note: you should not be using the same item group for input and output, as the output contributes to the item group but would not replace it.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.PsiGen.Tasks.RemoveItemsInFolderTaskStub.#ctor(System.Collections.Generic.Dictionary{System.String,System.String}[],System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.String}})">
            <summary>
            This complies with the <c>ProxyToSolutionCompiledTask</c> calling convention.
            </summary>
        </member>
    </members>
</doc>
